{- Homology Theory:
   - unit Differential Group;
   - Chain Complexes.
   - Ker, Im;
   Copyright (c) Groupoid Infinity, 2016-2018. -}

module homology where
import int
import set
import algebra
import quotient

isDifferentialGroup (G: SET): U
  = (g: isGroup G)
  * (comm: isCommutative G.1 g.1.1)
  * (boundary: G.1 -> G.1)
  * ((x: G.1) -> Path G.1 (boundary (boundary x)) g.1.2.2.1)

unitDGroup: dgroup
  = ((unit,setUnit),(((op,asso,id,(lx,rx)),inv,(li,ri)),comm,b,z)) where
    op: unit -> unit -> unit = \(x y: unit) -> y
    id: unit = tt
    inv: unit -> unit = \(x: unit) -> tt
    lx: (x: unit) -> Path unit (op id x) x = \(x: unit) -> <i> (op id x)
    rx: (x: unit) -> Path unit (op x id) x = split tt -> <i> tt
    li: (x: unit) -> Path unit (op (inv x) x) id = split tt -> <i> tt
    ri: (x: unit) -> Path unit (op x (inv x)) id = split tt -> <i> tt
    b: unit -> unit = idfun unit
    z: (x: unit) -> Path unit (b (b x)) id = split tt -> <i> tt
    asso: isAssociative unit op = \(x y z: unit) -> <i> z
    comm: isCommutative unit op = split tt -> \(y: unit) -> <i> rx y @ -i

-- Group Homomorphism Kernels and Cokernels
-- are just Homotopy Pullbacks and Pushouts pullback.ctt

homGroup (G H: group) (f: G.1.1 -> H.1.1): U
  = (g1 g2: G.1.1) * Path H.1.1 (f (G.2.1.1 g1 g2)) (H.2.1.1 (f g1) (f g2))

kerGroup (G H: group) (f: G.1.1 -> H.1.1): U
  = (g: G.1.1) * (Path H.1.1 (f g) H.2.1.2.2.1)

kerDGroup (G H: dgroup) (f: G.1.1 -> H.1.1): U
  = (g: G.1.1) * (Path H.1.1 (f g) (idGroup (H.1,H.2.1)))

imGroup (G H: group) (f: G.1.1 -> H.1.1): U
  = (h: H.1.1) * (g: G.1.1) * (Path H.1.1 (f g) h)

kerRing  (G H: ring)  (f: G.1.1 -> H.1.1): U
  = (g: G.1.1) * (Path H.1.1 (f g) H.2.2.1.1.1.2.2.1)

kerAb (G H: abgroup)  (f: G.1.1 -> H.1.1): U
  = (g: G.1.1) * (Path H.1.1 (f g) H.2.1.1.2.2.1)

ChainComplex: U
  = (head: dgroup)
  * (chain: nat -> dgroup)
  * (augment: dgrouphom (chain zero) head)
  * ((n: nat) -> dgrouphom (chain (succ n)) (chain n))

CochainComplex: U
  = (head: dgroup)
  * (cochain: nat -> dgroup)
  * (augment: dgrouphom head (cochain zero))
  * ((n: nat) -> dgrouphom (cochain n) (cochain (succ n)))

homology_group (x: ChainComplex): (n: Z) -> dgroup = split
   inl x -> unitDGroup
   inr x -> natElim x where
   natElim: nat -> dgroup = split
      zero -> unitDGroup -- TODO:
      succ x -> unitDGroup -- TODO:

diff (H: dgroup) (g h: H.1.1) : H.1.1
  = (opGroup (H.1,H.2.1)) g ((invGroup (H.1,H.2.1)) h)

subtypeProp (A: U): U
  = (P: A -> U) * (a: A) -> isProp (P a)

conj (G: dgroup) (g1 g2: G.1.1): G.1.1
  = op (op g1 g2) (inv g1) where
    g:   group = (G.1,G.2.1)
    op:  g.1.1 -> g.1.1 -> g.1.1 = opGroup g
    inv: g.1.1 -> g.1.1 = invGroup g

subtype (A: U) (P: subtypeProp A): U
  = (x: A) * (P.1 x)

subgroupProp (G: dgroup): U
  = (prop: G.1.1 -> U)
  * (level: (x: G.1.1) -> isProp (prop x))
  * (ident: prop (idGroup (G.1,G.2.1)))
  * ((g1 g2: G.1.1) -> prop g1 -> prop g2 -> prop (diff G g1 g2))

isNormal (G: dgroup) (P: subgroupProp G) : U
  = (g1 g2: G.1.1) -> P.1 g2 -> P.1 (conj G g1 g2)

normalSubgroupProp (G: dgroup): U
  = (P: subgroupProp G)
  * isNormal G P

subElProp (G: dgroup) (H: subgroupProp G)
  : subtypeProp G.1.1
  = (H.1,H.2.1)

subEl (G: dgroup) (H: subgroupProp G): U
  = subtype G.1.1 (subElProp G H)

ker_prop (G H: dgroup) (phi: dgrouphom G H)
  : subgroupProp G
  = (prop,level,ident,di) where
    g: group = (G.1,G.2.1)
    h: group = (H.1,H.2.1)
    prop: G.1.1 -> U = \ (g: G.1.1) -> Path H.1.1 (phi.1 g) (idGroup h)
    level: (x: G.1.1) -> isProp (prop x) = undefined -- TODO:
    ident: prop (idGroup g) = undefined -- TODO:
    di: (g1 g2: G.1.1) -> prop g1 -> prop g2 -> prop (diff G g1 g2) = undefined -- TODO:

KerImRel (G H: dgroup) (phi: dgrouphom G H) (x y: H.1.1): U
  = pTrunc (fiber G.1.1 H.1.1 phi.1 (diff H x y))

KerImEl (G H: dgroup) (phi: dgrouphom G H): U
  = quot H.1.1 (KerImRel G H phi)

Ker (G H: dgroup) (phi: dgrouphom G H): dgroup
  = undefined -- Normal Subgroup of G

Im (H K: dgroup) (psi: dgrouphom H K): dgroup
  = undefined -- Subgroup of K

-- is-normal : ∀ {i j} {G : Group i} → SubgroupProp G j → Type (lmax i j)
-- is-normal {G = G} P = ∀ g₁ {g₂} → P.prop g₂ → P.prop (Group.conj G g₁ g₂)
-- NormalSubgroupProp : ∀ {i} (G : Group i) j → Type (lmax i (lsucc j))
-- NormalSubgroupProp {i} G j = Σ (SubgroupProp G j) is-normal
-- conj : El → El → El
-- conj g₁ g₂ = (g₁ ⊙ g₂) ⊙ inv g₁
-- diff : El → El → El
-- diff g h = g ⊙ inv h
-- Subtype : Type (lmax i j)
-- Subtype = Σ A P.prop
-- ker/im-rel' : Rel H.El (lmax i j)
-- ker/im-rel' h₁ h₂ = Trunc -1 (hfiber φ.f (H.diff h₁ h₂))
-- ker/im-El : Type (lmax (lmax i j) k)
-- ker/im-El = SetQuot ker/im-rel
-- G ---φ--→ᴳ H ---ψ--→ᴳ K

--  ker-propᴳ = record {M} where
--    module M where
--       prop : G.El → Type j
--       prop g = φ.f g == H.ident
--       abstract
--         ident : prop G.ident
--         ident = φ.pres-ident
--         diff : {g₁ g₂ : G.El} → prop g₁ → prop g₂ → prop (G.diff g₁ g₂)
--         diff {g₁} {g₂} p₁ p₂ = φ.pres-diff g₁ g₂ ∙ ap2 H.diff p₁ p₂ ∙ H.inv-r H.ident
