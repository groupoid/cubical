{- Homology Theory:
   - Subgroups;
   - Chain Complexes.
   - Ker, Im;
   - Homology Group.
   Copyright (c) Groupoid Infinity, 2016-2018. -}

module homology where
import int
import set
import algebra
import quotient
import iso_sigma
import subtype

diff (H: group) (g h: H.1.1) : H.1.1
  = (opGroup H) g ((invGroup H) h)

conjugate (G: group) (g1 g2: G.1.1): G.1.1
   = diff G ((opGroup G) g1 g2) g1

subtypeProp (A: U): U
  = (P : A -> U)
  * (a : A) -> isProp (P a)

subtype (A : U) (P : subtypeProp A): U
  = (x : A) -- prop
  * (P.1 x) -- level

subgroupProp (G: group): U
  = (prop: G.1.1 -> U)
  * (level: (x: G.1.1) -> isProp (prop x))
  * (ident: prop (idGroup G))
  * (inv: (g: G.1.1) -> prop g -> prop ((invGroup G) g))
  * ((g1 g2: G.1.1) -> prop g1 -> prop g2 -> prop ((opGroup G) g1 g2))

subgroupPropDiff (G : group) (P : subgroupProp G) (g1 g2 : G.1.1)
  (u : P.1 g1) (v : P.1 g2) : P.1 (diff G g1 g2) =
  P.2.2.2.2 g1 ((invGroup G) g2) u (P.2.2.2.1 g2 v)

isNormal (G: group) (P: subgroupProp G) : U
  = (X: group)
  * (g1 g2: G.1.1) -> P.1 g2 -> P.1 (conjugate G g1 g2)

isFull (G: group) (P: subgroupProp G): U
  = (g: G.1.1) -> P.1 g

normalSubgroupProp (G: group): U
  = (P: subgroupProp G)
  * isNormal G P

subElProp (G: group) (P: subgroupProp G)
  : subtypeProp G.1.1
  = (P.1,P.2.1)

subEl (G: group) (P: subgroupProp G): U
  = subtype G.1.1 (subElProp G P)

isSetSubEl (G: group) (P: subgroupProp G): isSet (subEl G P)
  = setSig G.1.1 P.1 G.1.2 (\(x : G.1.1) -> propSet (P.1 x) (P.2.1 x))

subgroup (G: group) (P: subgroupProp G): group
  = ((subEl G P, isSetSubEl G P), ((op, assoc, id, (lx, rx)), inv, (li, ri))) where
    un: U = subEl G P
    op (x y: un): un = ((opGroup G) x.1 y.1, P.2.2.2.2 x.1 y.1 x.2 y.2)
    unPath (x y : un) (p : Path G.1.1 x.1 y.1) : Path un x y =
      subtypeEquality G.1.1 P.1 P.2.1 x y p
    assoc: isAssociative un op =
      \(x y z : un) -> unPath (op x (op y z)) (op (op x y) z)
                              ((isAssocGroup G) x.1 y.1 z.1)
    id: un = ((idGroup G),P.2.2.1)
    lx (x: un): Path un (op id x) x = unPath (op id x) x ((hasIdGroup G).1 x.1)
    rx (x: un): Path un (op x id) x = unPath (op x id) x ((hasIdGroup G).2 x.1)
    inv (x: un): un = ((invGroup G) x.1, P.2.2.2.1 x.1 x.2)
    li (x: un) : Path un (op (inv x) x) id =
      unPath (op (inv x) x) id ((hasInvGroup G).1 x.1)
    ri (x: un) : Path un (op x (inv x)) id =
      unPath (op x (inv x)) id ((hasInvGroup G).2 x.1)

ker_prop (G H: group) (phi: grouphom G H)
  : subgroupProp G
  = (prop,level,ident,inv,op) where
    prop (x: G.1.1): U = Path H.1.1 (phi.1 x) (idGroup H)
    ident: prop (idGroup G) = phi.2.2
    level (x: G.1.1): isProp (prop x) = \(p q: prop x) -> H.1.2 (phi.1 x) (idGroup H) p q
    inv (x: G.1.1) (p : prop x) : prop ((invGroup G) x) =
      <i> comp (<_> H.1.1) ((invGroup H) (p @ i))
               [ (i = 0) -> <j> lem_grouphom_inv G H phi x @ -j
               , (i = 1) -> lemma_group_inv_id H ]
    op (g1 g2: G.1.1) (p : prop g1) (q : prop g2) : prop ((opGroup G) g1 g2) =
      <i> comp (<_> H.1.1) ((opGroup H) (p @ i) (q @ i))
               [ (i = 0) -> <j> phi.2.1 g1 g2 @ -j
               , (i = 1) -> H.2.1.2.2.2.1 (idGroup H) ]

im_prop (G H: group) (phi: grouphom G H)
  : subgroupProp H
  = (prop, level, ident, inv, op) where
    prop (x: H.1.1): U = pTrunc (fiber G.1.1 H.1.1 phi.1 x)
    ident: prop (idGroup H) = inc ((idGroup G),<i>phi.2.2 @ -i)
    level (x: H.1.1): isProp (prop x) = pTruncIsProp (fiber G.1.1 H.1.1 phi.1 x)
    fib (x : H.1.1) : U = fiber G.1.1 H.1.1 phi.1 x
    inv (x: H.1.1) : prop x -> prop ((invGroup H) x) =
      pTruncLift (fib x) (fib ((invGroup H) x))
        (\(u : fib x) ->
          ((invGroup G) u.1,
           <i> comp (<_> H.1.1) ((invGroup H) (u.2 @ i))
                    [ (i = 0) -> <_> (invGroup H) x
                    , (i = 1) -> <j> lem_grouphom_inv G H phi u.1 @ -j ]))
    op (g1 g2: H.1.1) : prop g1 -> prop g2 -> prop ((opGroup H) g1 g2) =
      pTruncBinLift (fib g1) (fib g2) (fib ((opGroup H) g1 g2))
        (\(u : fib g1) (v : fib g2) ->
          ((opGroup G) u.1 v.1,
           <i> comp (<_> H.1.1) (phi.2.1 u.1 v.1 @ -i)
                    [ (i = 0) -> <j> (opGroup H) (u.2 @ -j) (v.2 @ -j)
                    , (i = 1) -> <_> phi.1 ((opGroup G) u.1 v.1) ]))

Ker (G: abgroup) (H: group) (phi: grouphom (G.1,G.2.1) H): group
  = subgroup (G.1,G.2.1) (ker_prop (G.1,G.2.1) H phi)

Im (G: group) (H: abgroup) (psi: grouphom G (H.1,H.2.1)): group
  = subgroup (H.1,H.2.1) (im_prop G (H.1,H.2.1) psi)

KerImRel (G H: group) (phi: grouphom G H) (x y: H.1.1): U
  = pTrunc (fiber G.1.1 H.1.1 phi.1 (diff H x y))

KerImEl (G H: group) (phi: grouphom G H): U
  = quot H.1.1 (KerImRel G H phi)

mutual
  data Seq (A: U) (B: A -> A -> U)
     = seqNil (ob: A)
     | seqCons (ob: A) (seq: Seq A B) (hom: B ob (head A B seq))
  head (A: U) (B: A -> A -> U): Seq A B -> A = split
     seqNil x -> x
     seqCons x y z -> x

ChainComplex: U
  = (sequence: Seq abgroup abgrouphom)
  * (index: nat -> abgroup)
  * (augment: abgrouphom (index zero) (head abgroup abgrouphom sequence))
  * ((n: nat) -> abgrouphom (index (succ n)) (index n))

homology_group (x: ChainComplex): (n: Z) -> dgroup = split
   inl x -> unitDGroup
   inr x -> natElim x where
   natElim: nat -> dgroup = split
      zero -> unitDGroup -- TODO:
      succ x -> unitDGroup -- TODO:

CochainComplex: U
  = (sequence: Seq abgroup abgrouphom)
  * (index: nat -> abgroup)
  * (augment: abgrouphom (head abgroup abgrouphom sequence) (index zero))
  * ((n: nat) -> abgrouphom (index n) (index (succ n)))

-- Theorems

kernel_is_normal (G H : group) (phi : grouphom G H) : normalSubgroupProp G
  = (ker, cond) where
    ker: subgroupProp G = ker_prop G H phi
    --                       phiUnfold
    --   φ (g1 * g2 * g1⁻¹) - - - - - - > φ g1 * φ g2 * (φ g1)⁻¹
    --            ^                               ^
    --            |                               |
    --            |                               |
    --            |                               |
    -- φ (g1 * g2) * φ g1⁻¹ ------------> φ g1 * φ g2 * φ g1⁻¹
    phiUnfold (g1 g2 : G.1.1) :
      Path H.1.1 (phi.1 (conjugate G g1 g2))
                 ((opGroup H) ((opGroup H) (phi.1 g1) (phi.1 g2))
                              ((invGroup H) (phi.1 g1))) =
      <i> comp (<_> H.1.1) ((opGroup H) (phi.2.1 g1 g2 @ i) (phi.1 ((invGroup G) g1)))
               [ (i = 0) -> <j> phi.2.1 ((opGroup G) g1 g2) ((invGroup G) g1) @ -j
               , (i = 1) -> <j> ((opGroup H) ((opGroup H) (phi.1 g1) (phi.1 g2))
                                             (lem_grouphom_inv G H phi g1 @ j)) ]
    --                          conjOne
    -- φ g1 * φ g2 * (φ g1)⁻¹ - - - - - - > 1
    --         ^                            ^
    --         |                            |
    --         |                            |
    --         |                            |
    --  φ g1 * 1 * (φ g1)⁻¹  --------> φ g1 * (φ g1)⁻¹
    conjOne (g1 g2 : G.1.1) (p : Path H.1.1 (phi.1 g2) (idGroup H)) :
      Path H.1.1 ((opGroup H) ((opGroup H) (phi.1 g1) (phi.1 g2))
                              ((invGroup H) (phi.1 g1)))
                 (idGroup H) =
      <i> comp (<_> H.1.1) ((opGroup H) ((hasIdGroup H).2 (phi.1 g1) @ i)
                                        ((invGroup H) (phi.1 g1)))
               [ (i = 0) -> <j> (opGroup H) ((opGroup H) (phi.1 g1) (p @ -j))
                                            ((invGroup H) (phi.1 g1))
               , (i = 1) -> (hasInvGroup H).2 (phi.1 g1) ]
    --                        phiConj
    --     φ (g1 * g2 * g1⁻¹) - - - - - - > 1
    --             ^                        |
    --             |                        |
    -- phiUnfold⁻¹ |                        |
    --             |                        |
    --    φ g1 * g2 * (φ g1)⁻¹ -----------> 1
    --                           conjOne
    phiConj (g1 g2: G.1.1) (p : Path H.1.1 (phi.1 g2) (idGroup H)) :
      Path H.1.1 (phi.1 (conjugate G g1 g2)) (idGroup H)
      = <i> comp (<_> H.1.1) (conjOne g1 g2 p @ i)
                 [ (i = 0) -> <j> phiUnfold g1 g2 @ -j
                 , (i = 1) -> <_> idGroup H ]
    cond: isNormal G ker = (G, phiConj)

