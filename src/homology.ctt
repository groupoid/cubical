{- Homology Theory:
   - Differential Group, Abelian Groups, units;
   - Chain Complexes.
   - Ker, Im;
   - Homology Group.
   Copyright (c) Groupoid Infinity, 2016-2018. -}

module homology where
import int
import set
import algebra
import quotient

isDifferentialGroup (G: SET): U
  = (g: isGroup G)
  * (comm: isCommutative G.1 g.1.1)
  * (boundary: G.1 -> G.1)
  * ((x: G.1) -> Path G.1 (boundary (boundary x)) g.1.2.2.1)

unitDGroup: dgroup
  = ((unit,setUnit),(((op,asso,id,(lx,rx)),inv,(li,ri)),comm,b,z)) where
    op: unit -> unit -> unit = \(x y: unit) -> y
    id: unit = tt
    inv: unit -> unit = \(x: unit) -> tt
    lx: (x: unit) -> Path unit (op id x) x = \(x: unit) -> <i> (op id x)
    rx: (x: unit) -> Path unit (op x id) x = split tt -> <i> tt
    li: (x: unit) -> Path unit (op (inv x) x) id = split tt -> <i> tt
    ri: (x: unit) -> Path unit (op x (inv x)) id = split tt -> <i> tt
    b: unit -> unit = idfun unit
    z: (x: unit) -> Path unit (b (b x)) id = split tt -> <i> tt
    asso: isAssociative unit op = \(x y z: unit) -> <i> z
    comm: isCommutative unit op = split tt -> \(y: unit) -> <i> rx y @ -i

-- Group Homomorphism Kernels and Cokernels
-- are just Homotopy Pullbacks and Pushouts pullback.ctt

isGroupHom (G H: group): U
  = (f: G.1.1 -> H.1.1)
  * (g1 g2: G.1.1)
  * Path H.1.1 (f ((opGroup G) g1 g2)) ((opGroup H) (f g1) (f g2))

isHom (G H: dgroup): U
  = (f: G.1.1 -> H.1.1)
  * (g1 g2: G.1.1)
  * Path H.1.1 (f ((opGroup (G.1,G.2.1)) g1 g2)) ((opGroup (H.1,H.2.1)) (f g1) (f g2))

isGroupKer (G H: group): U
  = (f: G.1.1 -> H.1.1)
  * (g: G.1.1)
  * Path H.1.1 (f g) H.2.1.2.2.1

isKer (G H: dgroup) : U
  = (f: G.1.1 -> H.1.1)
  * (g: G.1.1)
  * Path H.1.1 (f g) (idGroup (H.1,H.2.1))

isIm (G H: group) : U
  = (f: G.1.1 -> H.1.1)
  * (h: H.1.1)
  * (g: G.1.1)
  * Path H.1.1 (f g) h

isKerRing  (G H: ring)  (f: G.1.1 -> H.1.1): U
  = (g: G.1.1)
  * (Path H.1.1 (f g) H.2.2.1.1.1.2.2.1)

isKerAb (G H: abgroup)  (f: G.1.1 -> H.1.1): U
  = (g: G.1.1)
  * (Path H.1.1 (f g) H.2.1.1.2.2.1)

diff (H: dgroup) (g h: H.1.1) : H.1.1
  = (opGroup (H.1,H.2.1)) g ((invGroup (H.1,H.2.1)) h)

conjugate (G: dgroup) (g1 g2: G.1.1): G.1.1
   = diff G (G.2.1.1.1 g1 g2) g1
-- = op (op g1 g2) (inv g1) where
--   inv: G.1.1 -> G.1.1 = invGroup (G.1,G.2.1)
--   op:  G.1.1 -> G.1.1 -> G.1.1 = opGroup (G.1,G.2.1)

subtypeProp (A: U): U
  = (P: A -> U)
  * (a: A) -> isProp (P a)

subtype (A: U) (P: subtypeProp A): U
  = (x: A) * (P.1 x) -- prop and level

subgroupProp (G: dgroup): U
  = (prop: G.1.1 -> U)
  * (level: (x: G.1.1) -> isProp (prop x))
  * (ident: prop (idGroup (G.1,G.2.1)))
  * (inv: (g: G.1.1) -> prop g -> prop ((invGroup (G.1,G.2.1)) g))
  * (op: (g1 g2: G.1.1) -> prop g1 -> prop g2 -> prop ((opGroup (G.1,G.2.1)) g1 g2))
  * ((g1 g2: G.1.1) -> prop g1 -> prop g2 -> prop (diff G g1 g2))

isNormal (G: dgroup) (P: subgroupProp G) : U
  = (X: dgroup)
  * (g1 g2: G.1.1) -> P.1 g2 -> P.1 (conjugate G g1 g2)

normalSubgroupProp (G: dgroup): U
  = (P: subgroupProp G)
  * isNormal G P

subElProp (G: dgroup) (P: subgroupProp G)
  : subtypeProp G.1.1
  = (P.1,P.2.1)

subEl (G: dgroup) (P: subgroupProp G): U
  = subtype G.1.1 (subElProp G P)

isSetSubEl (G: dgroup) (P: subgroupProp G): isSet (subEl G P)
  = undefined

subgroup (G: dgroup) (P: subgroupProp G): group
  = ((subEl G P,isSetSubEl G P),(op,asso,id,(lx,rx)),inv,(li,ri)) where
    g: group = (G.1,G.2.1)
    un: U = subEl G P
    op: un -> un -> un = undefined
    id: un = undefined
    inv (x: un): un = ((invGroup g) x.1,P.2.2.2.1 x.1 x.2)
    lx: (x: un) -> Path un (op id x) x = undefined
    rx: (x: un) -> Path un (op x id) x = undefined
    li: (x: un) -> Path un (op (inv x) x) id = undefined
    ri: (x: un) -> Path un (op x (inv x)) id = undefined
    asso: isAssociative un op = undefined

ker_prop (G H: dgroup) (phi: dgrouphom G H)
  : subgroupProp G
  = (prop,level,ident,inv,op,di) where
    g: group = (G.1,G.2.1)
    h: group = (H.1,H.2.1)
    prop (g: G.1.1): U = Path H.1.1 (phi.1 g) (idGroup h)
    ident: prop (idGroup g) = phi.2.2
    level (x: G.1.1): isProp (prop x) = undefined
    inv: (g: G.1.1) -> prop g -> prop ((invGroup (G.1,G.2.1)) g) = undefined
    op: (g1 g2: G.1.1) -> prop g1 -> prop g2 -> prop ((opGroup (G.1,G.2.1)) g1 g2) = undefined
    di: (g1 g2: G.1.1) -> prop g1 -> prop g2 -> prop (diff G g1 g2) = undefined
        -- phi.2.1 g1 (invGroup g2) âˆ™ ap ((opGroup H) (g2 g2)) (phi.2.2 g2)

im_prop (G H: dgroup) (phi: dgrouphom G H)
  : subgroupProp H
  = (prop,level,ident,inv,op,di) where
    g: group = (G.1,G.2.1)
    h: group = (H.1,H.2.1)
    prop (x: H.1.1): U = pTrunc (fiber G.1.1 H.1.1 phi.1 x)
    ident: prop (idGroup h) = inc ((idGroup g),<i>phi.2.2 @ -i)
    level (x: H.1.1): isProp (prop x) = pTruncIsProp (fiber G.1.1 H.1.1 phi.1 x)
    inv: (g: H.1.1) -> prop g -> prop ((invGroup (H.1,H.2.1)) g) = undefined
    op: (g1 g2: H.1.1) -> prop g1 -> prop g2 -> prop ((opGroup (H.1,H.2.1)) g1 g2) = undefined
    di: (h1 h2: H.1.1) -> prop h1 -> prop h2 -> prop (diff H h1 h2) = undefined

Ker (G H: dgroup) (phi: dgrouphom G H): group
  = subgroup G (ker_prop G H phi)

Im (G H: dgroup) (psi: dgrouphom G H): group
  = subgroup H (im_prop G H psi)

KerImRel (G H: dgroup) (phi: dgrouphom G H) (x y: H.1.1): U
  = pTrunc (fiber G.1.1 H.1.1 phi.1 (diff H x y))

KerImEl (G H: dgroup) (phi: dgrouphom G H): U
  = quot H.1.1 (KerImRel G H phi)

mutual
  data Seq (A: U) (B: A -> A -> U)
     = seqNil (ob: A)
     | seqCons (ob: A) (seq: Seq A B) (hom: B ob (head A B seq))
  head (A: U) (B: A -> A -> U): Seq A B -> A = split
     seqNil x -> x
     seqCons x y z -> x

ChainComplex: U
  = (sequence: Seq dgroup dgrouphom)
  * (index: nat -> dgroup)
  * (augment: dgrouphom (index zero) (head dgroup dgrouphom sequence))
  * ((n: nat) -> dgrouphom (index (succ n)) (index n))

homology_group (x: ChainComplex): (n: Z) -> dgroup = split
   inl x -> unitDGroup
   inr x -> natElim x where
   natElim: nat -> dgroup = split
      zero -> unitDGroup -- TODO:
      succ x -> unitDGroup -- TODO:

CochainComplex: U
  = (sequence: Seq dgroup dgrouphom)
  * (index: nat -> dgroup)
  * (augment: dgrouphom (head dgroup dgrouphom sequence) (index zero))
  * ((n: nat) -> dgrouphom (index n) (index (succ n)))
